ccopy_reg
_reconstructor
p1
(cpsychopy.data
StairHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'origin'
p6
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.00), Mon Mar 16 14:30:23 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, sound, gui #,logging\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport itertools\u000aimport shutil\u000a\u000aimport pyglet\u000aallScrs = pyglet.window.get_platform().get_default_display().get_screens()\u000aprint allScrs\u000a\u000a# mainWin = visual.Window([1680,1050], units='norm', fullscr=True, screen=0) \u000a# secondWin = visual.Window([1680,1050], units='norm', fullscr=True, screen=1) \u000a\u000a# ====================================================================================\u000a## Initial variables.\u000a# Window boxes and black boxes (specified in degrees of visual angles [dva]):\u000awindowSize = 5.03 # 4.47\u000awindowOffsetX = 5.62 # 6.71\u000awindowOffsetY = 2.83 # 4.97\u000awindowThickness = 2\u000atargVertOffset = 1.5\u000ablackBoxSize = windowSize + 0.5\u000ablackBoxThickness = 10\u000a# Mask variables:\u000anMaskElements = 160 # must be divisible by the number of directions allowed (below)\u000amaskDirections = [[1,0],[-1,0],[0,1],[0,-1]] # right, left, up, down\u000a# Timing variables (in seconds) and trial number:\u000apreStimInterval = 1\u000astimDuration = 2 # 3.6s in the Moors paper\u000aISIduration = 0.0 # 0.5 before\u000afadeInNofFrames = 20 # the number of frames for the fade-in\u000a# Criteria for contrast staircases:\u000anTrialsPerStair = 30 # 30\u000acontrMin = 0\u000acontrMax = 1\u000a# Other variables:\u000aconditionsFileName = 'cond-expt01.csv'\u000a#conditionsFileName = 'cond-expt01-partial.csv'\u000acontrSteps = [0.3, 0.3, 0.2, 0.2, 0.1, 0.1, 0.05, 0.05, 0.03, 0.03]\u000atargInitPosAll = [-1, 0, 1] # multiplier for starting target position along x-axis\u000a# ====================================================================================\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'supreff'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'01', u'domEye': u'r', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName) # dialogue box\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data' + os.sep + '%s_%s_%s_%s_%s' %(expName, \u000a    expInfo['participant'], expInfo['domEye'], expInfo['session'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='', extraInfo=expInfo, \u000a    runtimeInfo=None, originPath=None, savePickle=True, saveWideText=True, \u000a    dataFileName=filename)\u000a##save a log file for detail verbose info\u000a#logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a#logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1680, 1050), fullscr=False, screen=1, allowGUI=False, \u000a    allowStencil=False, monitor='testMonitor', color='black', colorSpace='rgb', \u000a    blendMode='avg', useFBO=True, units='deg')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text='Indicate whether the red circle appeared above or below fixation:\u005cn\u005cn"up" = above\u005cn"down" = below \u005cn\u005cn The frames will turn *yellow* when the target disappeared.',\u000a    font='Cambria', pos=[0, 0], height=1, wrapWidth=10, color='white', \u005c\u000a    colorSpace='rgb', opacity=1)\u000a\u000a# Initial positions of the mask:\u000amaskInitPos = np.zeros((nMaskElements,2))\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000amoveClock = core.Clock()\u000amaskMoveClock = core.Clock()\u000awindowLeft = visual.Rect(win=win, name='windowLeft', width=[windowSize, \u000a    windowSize][0], height=[windowSize, windowSize][1], ori=0, \u000a    pos=[-windowOffsetX, windowOffsetY], \u000a    lineWidth=windowThickness, lineColor=u'white', lineColorSpace='rgb', \u000a    fillColor=None, opacity=1, interpolate=True)\u000awindowRight = visual.Rect(win=win, name='windowRight', width=[windowSize, \u000a    windowSize][0], height=[windowSize, windowSize][1], ori=0, \u000a    pos=[windowOffsetX, windowOffsetY], lineWidth=windowThickness, \u000a    lineColor=u'white', lineColorSpace='rgb', \u000a    fillColor=None, opacity=1, interpolate=True)\u000ablackBoxLeft = visual.Rect(win=win, name='blackBoxLeft', width=[blackBoxSize, \u000a    blackBoxSize][0], height=[blackBoxSize, blackBoxSize][1], ori=0, \u000a    pos=[-windowOffsetX, windowOffsetY], lineWidth=blackBoxThickness, \u000a    lineColor=u'black', \u000a    lineColorSpace='rgb', fillColor=None, opacity=1, interpolate=True)\u000ablackBoxRight = visual.Rect(win=win, name='blackBoxRight', width=[blackBoxSize, \u000a    blackBoxSize][0], height=[blackBoxSize, blackBoxSize][1], ori=0, \u000a    pos=[windowOffsetX, windowOffsetY], lineWidth=blackBoxThickness, \u000a    lineColor=u'black', \u000a    lineColorSpace='rgb', fillColor=None, opacity=1, interpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a# setting the edges to 3 (triangle) initially: this will change once ...\u000a# ... the attributes are read from the configuration file:\u000atarget = visual.Polygon(win=win, name='target',units='deg', edges = 3, size=[0.1, 0.1],\u000a    ori=0, pos=[0, 0], lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb', opacity=1, interpolate=True)\u000a# field size needs to be changed later on in the code:\u000amask = visual.ElementArrayStim(win=win, name='mask', units='deg', \u000a    fieldSize=(windowSize,windowSize), fieldShape='sqr', colors=(1,1,1), \u000a    colorSpace='rgb', opacities=1, fieldPos=[0,0], sizes=1, nElements=nMaskElements, \u000a    elementMask=None, elementTex=None, sfs=3, xys=maskInitPos, interpolate=True)\u000a# fixation crosses:\u000afixationLeft = visual.GratingStim(win, name='fixationLeft', color='white', \u000a    tex=None, mask='circle', size=0.2, pos=[-windowOffsetX, windowOffsetY])\u000afixationRight = visual.GratingStim(win, name='fixationRight', color='white', \u000a    tex=None, mask='circle', size=0.2, pos=[windowOffsetX, windowOffsetY])\u000a# pause text:\u000apauseTextLeft = visual.TextStim(win=win, ori=0, name='pauseTextLeft',\u000a    text='Press Spacebar to continue.', font='Cambria', alignHoriz='center',\u000a    pos=[-windowOffsetX, windowOffsetY], height=.7, wrapWidth=3, color='white',\u000a    colorSpace='rgb', opacity=1)\u000apauseTextRight = visual.TextStim(win=win, ori=0, name='pauseTextRight',\u000a    text='Press Spacebar to continue.', font='Cambria', alignHoriz='center',\u000a    pos=[windowOffsetX, windowOffsetY], height=.7, wrapWidth=3, color='white',\u000a    colorSpace='rgb', opacity=1)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstrKey = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstrKey.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(instrText)\u000ainstructionsComponents.append(instrKey)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a    \u000a    # *instrKey* updates\u000a    if t >= 0.0 and instrKey.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrKey.tStart = t  # underestimates by a little under one frame\u000a        instrKey.frameNStart = frameN  # exact frame index\u000a        instrKey.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if instrKey.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# Setting up the staircases.\u000astairConds = data.importConditions(conditionsFileName)\u000a# print stairConds\u000anConditions = np.size(stairConds)\u000aprint "number of conditions: " + str(nConditions)\u000a\u000a# ====================================================================================\u000a## Preparing the mask and the target.\u000a# Target starting position (assuming that the target is always presented to the non-dominant eye):\u000aif expInfo['domEye'] == 'r': # if the dominant eye is right...\u000a    targOffsetX = -windowOffsetX\u000a    maskOffsetX = windowOffsetX\u000aelif expInfo['domEye'] == 'l': # if the dominant eye is left...\u000a    targOffsetX = windowOffsetX\u000a    maskOffsetX = -windowOffsetX\u000a# The target directions and starting positions must be random:\u000atargDirAll = (np.random.randint(2,size=nTrialsPerStair)*2-1) # -1=left, +1=right\u000atargDirAll = np.repeat(targDirAll, nConditions, 0)\u000atargDirAll = np.random.permutation(targDirAll)\u000a# note that this is NOT YET multiplied by the max travel distance:\u000atargInitPos = (np.random.rand(nTrialsPerStair)*2-1)\u000a\u000a# Creating combinations of directions and starting positions of the target:\u000acombi_dirXpos = list(itertools.product(*[[-1,1],targInitPosAll]))\u000a#print combi_dirXpos\u000anCombiReps = nTrialsPerStair / np.shape(combi_dirXpos)[0]\u000a#print nCombiReps\u000a# Setting up each staircase, one by one:\u000astairs=[] # setting up a variable containing all our staircases\u000afor thisCondition in stairConds:\u000a    # I want to record the sequence of the combinations, but not sure if it's a good\u000a    #  idea, since I don't know how it's going to handle the output. I can do the\u000a    #  conversion prior to the output, I guess.\u000a    thisCombi_dirXpos = np.random.permutation(np.repeat(combi_dirXpos, nCombiReps, 0))\u000a    thisCondition['combi_dirXpos'] = thisCombi_dirXpos\u000a    thisStair = data.StairHandler(startVal = thisCondition['startVal'],\u000a        extraInfo = thisCondition, nTrials=nTrialsPerStair, nUp=1, nDown=2,\u000a        minVal = contrMin, maxVal = contrMax, stepSizes = contrSteps, stepType='lin')\u000a    thisStair.setExp(thisExp)\u000a    stairs.append(thisStair)\u000a    stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a        expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a        expInfo['date'] + '_cond_' + thisStair.extraInfo['label']) #str(condN))\u000a    print stairFilename\u000a    thisStair.saveAsPickle(stairFilename)\u000a    thisStair.saveAsText(stairFilename)\u000a# Printing the attributes of the stairs:  \u000aprint dir(stairs[0])\u000a# Creating a directory for storing staircase outputs:\u000aif not os.path.exists(filename):\u000a    os.makedirs(filename)\u000a# Creating a copy of the Conditions file for book-keeping and analyses:\u000ashutil.copyfile(conditionsFileName, filename + os.sep + conditionsFileName)\u000a\u000a# Annoyingly, the right side of the following appears everywhere. More efficient to\u000a#   store this as a variable since it is fixed:\u000astimOffset = (preStimInterval + (stimDuration-win.monitorFramePeriod*0.75))\u000a# ====================================================================================\u000a\u000afor trialN in range(nTrialsPerStair):\u000a    shuffle(stairs) # randomizing the appearance of the stairs for each trial\u000a    for thisStair in stairs:\u000a        # Based on the current staircase, assigning the current contrast value and\u000a        #  other variables:\u000a        thisIntensity = thisStair.next() # contrast value\u000a        thisTargDir = thisStair.extraInfo['combi_dirXpos'][trialN,0]\u000a        thisTargInitPos = thisStair.extraInfo['combi_dirXpos'][trialN,1]\u000a        thisTargSize = thisStair.extraInfo['targSize']\u000a        thisTargLoc = thisStair.extraInfo['targLoc']\u000a        thisTargVertices = thisStair.extraInfo['targVertices']\u000a        thisTargSpeed = thisStair.extraInfo['targSpeed']\u000a        thisTargColour = thisStair.extraInfo['targColour']\u000a        thisTargCorrAns = thisStair.extraInfo['targCorrAns']\u000a        thisMaskVertices = thisStair.extraInfo['maskVertices']\u000a        thisMaskSize = thisStair.extraInfo['maskSize']\u000a        thisMaskSpeed = thisStair.extraInfo['maskSpeed']\u000a        thisMaskColRed = thisStair.extraInfo['maskColRed']\u000a        thisMaskColGreen = thisStair.extraInfo['maskColGreen']\u000a        thisMaskColYellow = thisStair.extraInfo['maskColYellow']\u000a        thisMaskColBlue = thisStair.extraInfo['maskColBlue']\u000a        thisMaskColGrey = thisStair.extraInfo['maskColGrey']\u000a        # What changes from trial to trial (will be different for dif expts)?\u000a        print '### Trial ' + str(trialN) + ' ###'\u000a        print 'thisIntensity (contrast): start=%.2f, current=%.3f' \u005c\u000a            %(thisStair.extraInfo['startVal'], thisIntensity)\u000a        print 'thisTargLoc: ' + str(thisTargLoc)\u000a        print 'thisMaskSpeed: ' + str(thisMaskSpeed)\u000a        print 'thisTargDir: ' + str(thisTargDir)\u000a        print 'thisTargInitPos: ' + str(thisTargInitPos)\u000a        #print 'thisCondition: ' + str(thisCondition)\u000a        # Setting up the size specifications:\u000a        target.size = [thisTargSize, thisTargSize] # target size\u000a        mask.sizes = [thisMaskSize, thisMaskSize] # mask size\u000a        # Maximum travel distance from the initial position:\u000a        maxTravDist = (windowSize - thisTargSize/1) / 2\u000a        # Resetting the starting positions of mask elements - \u000a        #  (assuming that the mask is different for every trial):\u000a        maskInitPos = (np.random.rand(nMaskElements,2)*2-1)*maxTravDist\u000a\u000a        # Picking a list of directions. If there are four allowed directions, \u000a        #  one out of four needs to be picked for each element equally. \u000a        #  [1 4 2 3 4 2 1 3...]\u000a        # number of times to repeat the directions: \u000a        maskDirectionNumReps = nMaskElements/np.shape(maskDirections)[0] \u000a        maskDirectionIndices = np.repeat(range(1,5), maskDirectionNumReps)\u000a        maskDirs = np.random.permutation(np.repeat(maskDirections,\u000a            maskDirectionNumReps,0))\u000a        # Setting the mask colours.\u000a        maskColIDs = np.array([thisMaskColRed, thisMaskColBlue, thisMaskColGreen,\u000a            thisMaskColYellow])\u000a        maskColAll = np.array([[1,-1,-1], [-1,-1,1], [-1,1,-1], [1,1,-1]])\u000a        maskColCurSet = maskColAll[maskColIDs==1]\u000a        maskColNumReps = nMaskElements/np.shape(maskColCurSet)[0]\u000a        maskColCurSetRepd = np.repeat(maskColCurSet, maskColNumReps, 0)\u000a        maskColours = np.random.permutation(maskColCurSetRepd)\u000a        mask.colors = maskColours\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        tMaskMove = 0\u000a        key_pressed = False\u000a        key_pause = False\u000a        windowLeft.lineColor = 'white'\u000a        windowRight.lineColor = 'white'\u000a        # Vertical offset of the target (dependent on the type of trial):\u000a        if thisTargLoc == 'above':\u000a            targOffsetY = windowOffsetY + targVertOffset\u000a        elif thisTargLoc == 'below':\u000a            targOffsetY = windowOffsetY - targVertOffset\u000a        else:\u000a            print 'Error! Please check your target location values.'\u000a        # update component parameters for each repeat\u000a        target.edges = thisTargVertices # updating the shape of the target\u000a        target.setFillColor(thisTargColour)\u000a        target.setLineColor(thisTargColour)\u000a        key_upDown = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_upDown.status = NOT_STARTED\u000a        key_space = event.BuilderKeyResponse()\u000a        key_space.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(windowLeft)\u000a        trialComponents.append(windowRight)\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(target)\u000a        trialComponents.append(mask)\u000a        trialComponents.append(fixationLeft)\u000a        trialComponents.append(fixationRight)\u000a        trialComponents.append(key_upDown)\u000a        trialComponents.append(key_space)\u000a        trialComponents.append(pauseTextLeft)\u000a        trialComponents.append(pauseTextRight)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1 # number of completed frames (0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *windowLeft* updates\u000a            if windowLeft.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                windowLeft.tStart = t  # underestimates by a little under one frame\u000a                windowLeft.frameNStart = frameN  # exact frame index\u000a                windowLeft.setAutoDraw(True)\u000a                fixationLeft.setAutoDraw(True)\u000a                blackBoxLeft.setAutoDraw(True)\u000a#            if windowLeft.status == STARTED and t >= stimOffset:\u000a#                windowLeft.setAutoDraw(False)\u000a#                fixationLeft.setAutoDraw(False)\u000a#                blackBoxLeft.setAutoDraw(False)\u000a            \u000a            # *windowRight* updates\u000a            if windowRight.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                windowRight.tStart = t  # underestimates by a little under one frame\u000a                windowRight.frameNStart = frameN  # exact frame index\u000a                windowRight.setAutoDraw(True)\u000a                fixationRight.setAutoDraw(True)\u000a                blackBoxRight.setAutoDraw(True)\u000a#            if windowRight.status == STARTED: #and t >= stimOffset:\u000a#                windowRight.setAutoDraw(False)\u000a#                fixationRight.setAutoDraw(False)\u000a#                blackBoxRight.setAutoDraw(False)\u000a\u000a            # if the target has already disappeared, yet the key is still not pressed\u005c\u000a            #   continue, the trial with the yellow boxes:\u000a            if ~key_pressed and t > stimOffset:\u000a                windowLeft.lineColor = 'yellow'\u000a                windowRight.lineColor = 'yellow'\u000a\u000a            # pause text (after the response is made):\u000a            if key_pressed and ~key_pause and t > stimOffset:\u000a                pauseTextLeft.setAutoDraw(True)\u000a                pauseTextRight.setAutoDraw(True)\u000a                windowLeft.lineColor = 'white'\u000a                windowRight.lineColor = 'white'\u000a\u000a            # *mask* updates\u000a            if mask.status == NOT_STARTED and t > preStimInterval:\u000a                mask.tStart = t\u000a                mask.frameNStart = frameN\u000a                # setting the initial positions for the mask elements\u000a                mask.xys = maskInitPos \u000a                mask.fieldPos = [maskOffsetX, windowOffsetY]\u000a                mask.setAutoDraw(True)\u000a                maskMoveClock.reset()\u000a            if mask.status == STARTED and t > preStimInterval and ~key_pressed:\u000a                if tMaskMove == 0:\u000a                    tMaskMove = frameDur # maskMoveClock.getTime()\u000a                    tMaskRec = maskMoveClock.getTime()\u000a                    maskMovePos = maskInitPos\u000a                else:\u000a                    tMaskMove = maskMoveClock.getTime() - tMaskRec\u000a                    tMaskRec = maskMoveClock.getTime()\u000a                maskMovePos = np.array(maskMovePos) + np.array(maskDirs) * \u005c\u000a                    thisMaskSpeed * tMaskMove\u000a                maskElemsOutside = np.where(abs(maskMovePos)>maxTravDist)\u000a                maskMovePos[maskElemsOutside] = -maxTravDist * \u005c\u000a                    maskMovePos[maskElemsOutside] / abs(maskMovePos[maskElemsOutside])\u000a                mask.xys = maskMovePos\u000a            if mask.status == STARTED and t >= stimOffset and key_pressed:\u000a                mask.setAutoDraw(False)\u000a\u000a            # *target* updates\u000a            if t >= preStimInterval and target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                target.tStart = t  # underestimates by a little under one frame\u000a                target.frameNStart = frameN  # exact frame index\u000a                target.setAutoDraw(True)\u000a                edgeReached = False\u000a                moveClock.reset()\u000a            if target.status == STARTED:\u000a                curFrameN = frameN - target.frameNStart\u000a                if curFrameN < fadeInNofFrames:\u000a                    target.opacity = thisIntensity * (curFrameN / fadeInNofFrames)\u000a                else:\u000a                    target.opacity = thisIntensity\u000a                tMove = moveClock.getTime()\u000a                if edgeReached: # if the edge is reached, start from the other edge:\u000a                    travDist = tMove*thisTargSpeed-maxTravDist\u000a                else: # otherwise, start from the middle of the box:\u000a                    travDist = tMove*thisTargSpeed\u000a                # if the target has already moved beyond max allowed travel distance:\u000a                if travDist > maxTravDist:\u000a                    edgeReached = True\u000a                    moveClock.reset() # reset the movement clock (set it to zero)\u000a                    tMove = moveClock.getTime() # get the time\u000a                    # use that reset time for new travDist, but start from the edge:\u000a                    travDist = tMove*thisTargSpeed-maxTravDist\u000a                # target movement:\u000a                target.pos = [targOffsetX+thisTargDir*travDist, targOffsetY]\u000a            if target.status == STARTED and t >= stimOffset:\u000a                target.setAutoDraw(False)\u000a\u000a            # *key_space* updates\u000a            if ~key_pause and key_pressed and t >= stimOffset:\u000a#                spaceKey = event.getKeys(keyList=['space'])\u000a                if 'space' in event.getKeys(keyList=['space']):\u000a                    print 'spacebar pressed'\u000a                    key_pause = True\u000a            \u000a            # *key_upDown* updates\u000a            if t >= preStimInterval and key_upDown.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_upDown.tStart = t  # underestimates by a little under one frame\u000a                key_upDown.frameNStart = frameN  # exact frame index\u000a                key_upDown.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_upDown.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_upDown.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['up', 'down'])\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_upDown.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_upDown.rt = key_upDown.clock.getTime()\u000a                    key_pressed = True\u000a                    # was this 'correct'?\u000a                    if (key_upDown.keys == str(thisTargCorrAns)) or \u005c\u000a                            (key_upDown.keys == thisTargCorrAns):\u000a                        print 'correct response'\u000a                        key_upDown.corr = 1\u000a                    else:\u000a                        print 'incorrect response'\u000a                        key_upDown.corr = 0\u000a                    # update staircase:\u000a                    thisStair.addData(key_upDown.corr)\u000a                    thisStair.addOtherData('key_upDown.rt', key_upDown.rt)\u000a#                    ########\u000a#                    # Printing for debug:\u000a#                    print 'RT: %.3f' %(key_upDown.rt)\u000a#                    print thisStair.data\u000a\u000a            # if key is not pressed, do nothing\u000a            # if key is pressed, wait for the presentation time to pass to terminate\u005c\u000a            #   the trial:\u000a            if key_pressed and key_pause and t >= stimOffset:\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a            # *ISI* period\u000a            if ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(ISIduration)\u000a            #one frame should pass before updating params and completing\u000a            elif ISI.status == STARTED: \u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            # a component has requested a forced-end of Routine:\u000a            if not continueRoutine: \u000a                # if we abort early the non-slip timer needs reset:\u000a                routineTimer.reset() \u000a                break\u000a            # will revert to True if at least one component still running\u000a            continueRoutine = False  \u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and \u005c\u000a                        thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            # don't flip if this routine is over or we'll get a blank screen\u000a            if continueRoutine:  \u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a                    expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a                    expInfo['date'] + '_cond_' + thisStair.extraInfo['label'])\u000a                thisStair.saveAsPickle(stairFilename)\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a        thisExp.nextEntry()\u000a    \u000a# Writing the separate outputs for the staircases:\u000a#dateStr = time.strtime("%b_%d_%H%M", time.localtime())\u000a#condN = 0 # the conditions are simply defined by their numbers\u000afor thisStair in stairs:\u000a#    condN += 1\u000a    print 'reversals:'\u000a    print thisStair.reversalIntensities\u000a    print 'mean of final 6 reversals = %.3f' \u005c\u000a        %(np.average(thisStair.reversalIntensities[-6:]))\u000a    stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a        expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a        expInfo['date'] + '_cond_' + thisStair.extraInfo['label']) #str(condN))\u000a    thisStair.saveAsPickle(stairFilename)\u000a    thisStair.saveAsText(stairFilename)\u000a\u000awin.close()\u000acore.quit()\u000a
p7
sS'nDown'
p8
I2
sS'_exp'
p9
I240133648
sS'reversalIntensities'
p10
(lp11
I0
aF0.29999999999999999
aF0.099999999999999978
aF0.29999999999999999
aI0
aF0.10000000000000001
aF0.050000000000000003
aF0.10000000000000001
aF0.040000000000000008
aF0.070000000000000007
asS'stepSizes'
p12
(lp13
F0.29999999999999999
aF0.29999999999999999
aF0.20000000000000001
aF0.20000000000000001
aF0.10000000000000001
aF0.10000000000000001
aF0.050000000000000003
aF0.050000000000000003
aF0.029999999999999999
aF0.029999999999999999
asS'nUp'
p14
I1
sS'startVal'
p15
cnumpy.core.multiarray
scalar
p16
(cnumpy
dtype
p17
(S'f8'
I0
I1
tRp18
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp19
sS'_nextIntensity'
p20
I0
sS'_warnUseOfNext'
p21
I01
sS'method'
p22
S'2AFC'
p23
sS'maxVal'
p24
I1
sS'stepSizeCurrent'
p25
F0.029999999999999999
sS'correctCounter'
p26
I1
sS'nReversals'
p27
I10
sS'minVal'
p28
I0
sS'otherData'
p29
(dp30
S'key_upDown.rt'
p31
(lp32
F1.2641620635986328
aF0.81408286094665527
aF0.71497106552124023
aF2.3999538421630859
aF0.86379098892211914
aF0.88001799583435059
aF0.94801092147827148
aF1.3140239715576172
aF1.112760066986084
aF0.89857792854309082
aF0.87798094749450684
aF0.83634305000305176
aF1.298677921295166
aF2.577225923538208
aF0.98142790794372559
aF1.029839038848877
aF2.6009838581085205
aF2.5186359882354736
aF1.1128129959106445
aF1.05246901512146
aF2.7359077930450439
aF1.5821740627288818
aF2.9660570621490479
aF2.317267894744873
aF1.2175760269165039
aF2.585604190826416
aF3.0841419696807861
aF2.919238805770874
aF3.5683588981628418
aF3.5219900608062744
assS'finished'
p33
I01
sS'stepType'
p34
S'lin'
p35
sS'data'
p36
(lp37
I1
aI1
aI1
aI0
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI1
aI1
aI1
asS'reversalPoints'
p38
(lp39
I3
aI5
aI6
aI8
aI13
aI15
aI17
aI19
aI22
aI24
asS'originPath'
p40
S'/Users/egor/Dropbox/projects/supr-eff/supreff/supreff.py'
p41
sS'name'
p42
S''
sS'extraInfo'
p43
(dp44
S'maskColYellow'
p45
g16
(g17
(S'i8'
I0
I1
tRp46
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp47
sS'targCorrAns'
p48
S'down'
p49
sS'maskSize'
p50
g16
(g18
S'q=\n\xd7\xa3p\xdd?'
tRp51
sS'maskColGrey'
p52
g16
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp53
sS'maskVertices'
p54
g16
(g46
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp55
sS'maskColBlue'
p56
g16
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp57
sS'targSize'
p58
g16
(g18
S'q=\n\xd7\xa3p\xdd?'
tRp59
sS'targColour'
p60
S'red'
p61
sS'label'
p62
S'2-below_h'
p63
sS'combi_dirXpos'
p64
cnumpy.core.multiarray
_reconstruct
p65
(cnumpy
ndarray
p66
(I0
tS'b'
tRp67
(I1
(I30
I2
tg17
(S'i4'
I0
I1
tRp68
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00'
tbsS'targVertices'
p69
g16
(g46
S'\x10\x00\x00\x00\x00\x00\x00\x00'
tRp70
sS'maskColRed'
p71
g16
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp72
sS'maskSpeed'
p73
g16
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp74
sS'targSpeed'
p75
g16
(g46
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp76
sS'startVal'
p77
g19
sS'maskColGreen'
p78
g16
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp79
sS'targLoc'
p80
S'below'
p81
ssS'currentDirection'
p82
S'down'
p83
sS'_variableStep'
p84
I01
sS'intensities'
p85
(lp86
g19
ag16
(g18
S'\x00\x00\x00\x00\x00\x00\xe0?'
tRp87
ag16
(g18
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp88
aI0
aF0.29999999999999999
aF0.29999999999999999
aF0.099999999999999978
aF0.29999999999999999
aF0.29999999999999999
aF0.19999999999999998
aF0.19999999999999998
aF0.099999999999999978
aF0.099999999999999978
aI0
aF0.10000000000000001
aF0.10000000000000001
aF0.050000000000000003
aF0.050000000000000003
aF0.10000000000000001
aF0.10000000000000001
aF0.070000000000000007
aF0.070000000000000007
aF0.040000000000000008
aF0.070000000000000007
aF0.070000000000000007
aF0.040000000000000008
aF0.040000000000000008
aF0.010000000000000009
aF0.010000000000000009
aI0
asS'initialRule'
p89
I0
sS'nTrials'
p90
I30
sS'thisTrialN'
p91
I29
sS'autoLog'
p92
I01
sb.
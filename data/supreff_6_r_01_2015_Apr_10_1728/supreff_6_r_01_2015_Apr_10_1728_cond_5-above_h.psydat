ccopy_reg
_reconstructor
p1
(cpsychopy.data
StairHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'origin'
p6
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.00), Mon Mar 16 14:30:23 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, sound, gui #,logging\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport itertools\u000aimport shutil\u000a\u000aimport pyglet\u000aallScrs = pyglet.window.get_platform().get_default_display().get_screens()\u000aprint allScrs\u000a\u000a# mainWin = visual.Window([1680,1050], units='norm', fullscr=True, screen=0) \u000a# secondWin = visual.Window([1680,1050], units='norm', fullscr=True, screen=1) \u000a\u000a# ====================================================================================\u000a## Initial variables.\u000a# Window boxes and black boxes (specified in degrees of visual angles [dva]):\u000awindowSize = 5.03 # 4.47\u000awindowOffsetX = 5.62 # 6.71\u000awindowOffsetY = 2.83 # 4.97\u000awindowThickness = 2\u000atargVertOffset = 1.5\u000ablackBoxSize = windowSize + 0.5\u000ablackBoxThickness = 10\u000a# Mask variables:\u000anMaskElements = 160 # must be divisible by the number of directions allowed (below)\u000amaskDirections = [[1,0],[-1,0],[0,1],[0,-1]] # right, left, up, down\u000a# Timing variables (in seconds) and trial number:\u000apreStimInterval = 1\u000astimDuration = 2 # 3.6s in the Moors paper\u000aISIduration = 0.0 # 0.5 before\u000afadeInNofFrames = 20 # the number of frames for the fade-in\u000a# Criteria for contrast staircases:\u000anTrialsPerStair = 30 # 30\u000acontrMin = 0\u000acontrMax = 1\u000a# Other variables:\u000aconditionsFileName = 'cond-expt01.csv'\u000a#conditionsFileName = 'cond-expt01-partial.csv'\u000acontrSteps = [0.3, 0.3, 0.2, 0.2, 0.1, 0.1, 0.05, 0.05, 0.03, 0.03]\u000atargInitPosAll = [-1, 0, 1] # multiplier for starting target position along x-axis\u000a# ====================================================================================\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'supreff'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'01', u'domEye': u'r', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName) # dialogue box\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data' + os.sep + '%s_%s_%s_%s_%s' %(expName, \u000a    expInfo['participant'], expInfo['domEye'], expInfo['session'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='', extraInfo=expInfo, \u000a    runtimeInfo=None, originPath=None, savePickle=True, saveWideText=True, \u000a    dataFileName=filename)\u000a##save a log file for detail verbose info\u000a#logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a#logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1680, 1050), fullscr=False, screen=1, allowGUI=False, \u000a    allowStencil=False, monitor='testMonitor', color='black', colorSpace='rgb', \u000a    blendMode='avg', useFBO=True, units='deg')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000ainstrText = visual.TextStim(win=win, ori=0, name='instrText',\u000a    text='Indicate whether the red circle appeared above or below fixation:\u005cn\u005cn"up" = above\u005cn"down" = below \u005cn\u005cn The frames will turn *yellow* when the target disappeared.',\u000a    font='Cambria', pos=[0, 0], height=1, wrapWidth=10, color='white', \u005c\u000a    colorSpace='rgb', opacity=1)\u000a\u000a# Initial positions of the mask:\u000amaskInitPos = np.zeros((nMaskElements,2))\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000amoveClock = core.Clock()\u000amaskMoveClock = core.Clock()\u000awindowLeft = visual.Rect(win=win, name='windowLeft', width=[windowSize, \u000a    windowSize][0], height=[windowSize, windowSize][1], ori=0, \u000a    pos=[-windowOffsetX, windowOffsetY], \u000a    lineWidth=windowThickness, lineColor=u'white', lineColorSpace='rgb', \u000a    fillColor=None, opacity=1, interpolate=True)\u000awindowRight = visual.Rect(win=win, name='windowRight', width=[windowSize, \u000a    windowSize][0], height=[windowSize, windowSize][1], ori=0, \u000a    pos=[windowOffsetX, windowOffsetY], lineWidth=windowThickness, \u000a    lineColor=u'white', lineColorSpace='rgb', \u000a    fillColor=None, opacity=1, interpolate=True)\u000ablackBoxLeft = visual.Rect(win=win, name='blackBoxLeft', width=[blackBoxSize, \u000a    blackBoxSize][0], height=[blackBoxSize, blackBoxSize][1], ori=0, \u000a    pos=[-windowOffsetX, windowOffsetY], lineWidth=blackBoxThickness, \u000a    lineColor=u'black', \u000a    lineColorSpace='rgb', fillColor=None, opacity=1, interpolate=True)\u000ablackBoxRight = visual.Rect(win=win, name='blackBoxRight', width=[blackBoxSize, \u000a    blackBoxSize][0], height=[blackBoxSize, blackBoxSize][1], ori=0, \u000a    pos=[windowOffsetX, windowOffsetY], lineWidth=blackBoxThickness, \u000a    lineColor=u'black', \u000a    lineColorSpace='rgb', fillColor=None, opacity=1, interpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a# setting the edges to 3 (triangle) initially: this will change once ...\u000a# ... the attributes are read from the configuration file:\u000atarget = visual.Polygon(win=win, name='target',units='deg', edges = 3, size=[0.1, 0.1],\u000a    ori=0, pos=[0, 0], lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb', opacity=1, interpolate=True)\u000a# field size needs to be changed later on in the code:\u000amask = visual.ElementArrayStim(win=win, name='mask', units='deg', \u000a    fieldSize=(windowSize,windowSize), fieldShape='sqr', colors=(1,1,1), \u000a    colorSpace='rgb', opacities=1, fieldPos=[0,0], sizes=1, nElements=nMaskElements, \u000a    elementMask=None, elementTex=None, sfs=3, xys=maskInitPos, interpolate=True)\u000a# fixation crosses:\u000afixationLeft = visual.GratingStim(win, name='fixationLeft', color='white', \u000a    tex=None, mask='circle', size=0.2, pos=[-windowOffsetX, windowOffsetY])\u000afixationRight = visual.GratingStim(win, name='fixationRight', color='white', \u000a    tex=None, mask='circle', size=0.2, pos=[windowOffsetX, windowOffsetY])\u000a# pause text:\u000apauseTextLeft = visual.TextStim(win=win, ori=0, name='pauseTextLeft',\u000a    text='Press Spacebar to continue.', font='Cambria', alignHoriz='center',\u000a    pos=[-windowOffsetX, windowOffsetY], height=.7, wrapWidth=3, color='white',\u000a    colorSpace='rgb', opacity=1)\u000apauseTextRight = visual.TextStim(win=win, ori=0, name='pauseTextRight',\u000a    text='Press Spacebar to continue.', font='Cambria', alignHoriz='center',\u000a    pos=[windowOffsetX, windowOffsetY], height=.7, wrapWidth=3, color='white',\u000a    colorSpace='rgb', opacity=1)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstrKey = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstrKey.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(instrText)\u000ainstructionsComponents.append(instrKey)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instrText* updates\u000a    if t >= 0.0 and instrText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrText.tStart = t  # underestimates by a little under one frame\u000a        instrText.frameNStart = frameN  # exact frame index\u000a        instrText.setAutoDraw(True)\u000a    \u000a    # *instrKey* updates\u000a    if t >= 0.0 and instrKey.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instrKey.tStart = t  # underestimates by a little under one frame\u000a        instrKey.frameNStart = frameN  # exact frame index\u000a        instrKey.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if instrKey.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# Setting up the staircases.\u000astairConds = data.importConditions(conditionsFileName)\u000a# print stairConds\u000anConditions = np.size(stairConds)\u000aprint "number of conditions: " + str(nConditions)\u000a\u000a# ====================================================================================\u000a## Preparing the mask and the target.\u000a# Target starting position (assuming that the target is always presented to the non-dominant eye):\u000aif expInfo['domEye'] == 'r': # if the dominant eye is right...\u000a    targOffsetX = -windowOffsetX\u000a    maskOffsetX = windowOffsetX\u000aelif expInfo['domEye'] == 'l': # if the dominant eye is left...\u000a    targOffsetX = windowOffsetX\u000a    maskOffsetX = -windowOffsetX\u000a# The target directions and starting positions must be random:\u000atargDirAll = (np.random.randint(2,size=nTrialsPerStair)*2-1) # -1=left, +1=right\u000atargDirAll = np.repeat(targDirAll, nConditions, 0)\u000atargDirAll = np.random.permutation(targDirAll)\u000a# note that this is NOT YET multiplied by the max travel distance:\u000atargInitPos = (np.random.rand(nTrialsPerStair)*2-1)\u000a\u000a# Creating combinations of directions and starting positions of the target:\u000acombi_dirXpos = list(itertools.product(*[[-1,1],targInitPosAll]))\u000a#print combi_dirXpos\u000anCombiReps = nTrialsPerStair / np.shape(combi_dirXpos)[0]\u000a#print nCombiReps\u000a# Setting up each staircase, one by one:\u000astairs=[] # setting up a variable containing all our staircases\u000afor thisCondition in stairConds:\u000a    # I want to record the sequence of the combinations, but not sure if it's a good\u000a    #  idea, since I don't know how it's going to handle the output. I can do the\u000a    #  conversion prior to the output, I guess.\u000a    thisCombi_dirXpos = np.random.permutation(np.repeat(combi_dirXpos, nCombiReps, 0))\u000a    thisCondition['combi_dirXpos'] = thisCombi_dirXpos\u000a    thisStair = data.StairHandler(startVal = thisCondition['startVal'],\u000a        extraInfo = thisCondition, nTrials=nTrialsPerStair, nUp=1, nDown=2,\u000a        minVal = contrMin, maxVal = contrMax, stepSizes = contrSteps, stepType='lin')\u000a    thisStair.setExp(thisExp)\u000a    stairs.append(thisStair)\u000a    stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a        expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a        expInfo['date'] + '_cond_' + thisStair.extraInfo['label']) #str(condN))\u000a    print stairFilename\u000a    thisStair.saveAsPickle(stairFilename)\u000a    thisStair.saveAsText(stairFilename)\u000a# Printing the attributes of the stairs:  \u000aprint dir(stairs[0])\u000a# Creating a directory for storing staircase outputs:\u000aif not os.path.exists(filename):\u000a    os.makedirs(filename)\u000a# Creating a copy of the Conditions file for book-keeping and analyses:\u000ashutil.copyfile(conditionsFileName, filename + os.sep + conditionsFileName)\u000a\u000a# Annoyingly, the right side of the following appears everywhere. More efficient to\u000a#   store this as a variable since it is fixed:\u000astimOffset = (preStimInterval + (stimDuration-win.monitorFramePeriod*0.75))\u000a# ====================================================================================\u000a\u000afor trialN in range(nTrialsPerStair):\u000a    shuffle(stairs) # randomizing the appearance of the stairs for each trial\u000a    for thisStair in stairs:\u000a        # Based on the current staircase, assigning the current contrast value and\u000a        #  other variables:\u000a        thisIntensity = thisStair.next() # contrast value\u000a        thisTargDir = thisStair.extraInfo['combi_dirXpos'][trialN,0]\u000a        thisTargInitPos = thisStair.extraInfo['combi_dirXpos'][trialN,1]\u000a        thisTargSize = thisStair.extraInfo['targSize']\u000a        thisTargLoc = thisStair.extraInfo['targLoc']\u000a        thisTargVertices = thisStair.extraInfo['targVertices']\u000a        thisTargSpeed = thisStair.extraInfo['targSpeed']\u000a        thisTargColour = thisStair.extraInfo['targColour']\u000a        thisTargCorrAns = thisStair.extraInfo['targCorrAns']\u000a        thisMaskVertices = thisStair.extraInfo['maskVertices']\u000a        thisMaskSize = thisStair.extraInfo['maskSize']\u000a        thisMaskSpeed = thisStair.extraInfo['maskSpeed']\u000a        thisMaskColRed = thisStair.extraInfo['maskColRed']\u000a        thisMaskColGreen = thisStair.extraInfo['maskColGreen']\u000a        thisMaskColYellow = thisStair.extraInfo['maskColYellow']\u000a        thisMaskColBlue = thisStair.extraInfo['maskColBlue']\u000a        thisMaskColGrey = thisStair.extraInfo['maskColGrey']\u000a        # What changes from trial to trial (will be different for dif expts)?\u000a        print '### Trial ' + str(trialN) + ' ###'\u000a        print 'thisIntensity (contrast): start=%.2f, current=%.3f' \u005c\u000a            %(thisStair.extraInfo['startVal'], thisIntensity)\u000a        print 'thisTargLoc: ' + str(thisTargLoc)\u000a        print 'thisMaskSpeed: ' + str(thisMaskSpeed)\u000a        print 'thisTargDir: ' + str(thisTargDir)\u000a        print 'thisTargInitPos: ' + str(thisTargInitPos)\u000a        #print 'thisCondition: ' + str(thisCondition)\u000a        # Setting up the size specifications:\u000a        target.size = [thisTargSize, thisTargSize] # target size\u000a        mask.sizes = [thisMaskSize, thisMaskSize] # mask size\u000a        # Maximum travel distance from the initial position:\u000a        maxTravDist = (windowSize - thisTargSize/1) / 2\u000a        # Resetting the starting positions of mask elements - \u000a        #  (assuming that the mask is different for every trial):\u000a        maskInitPos = (np.random.rand(nMaskElements,2)*2-1)*maxTravDist\u000a\u000a        # Picking a list of directions. If there are four allowed directions, \u000a        #  one out of four needs to be picked for each element equally. \u000a        #  [1 4 2 3 4 2 1 3...]\u000a        # number of times to repeat the directions: \u000a        maskDirectionNumReps = nMaskElements/np.shape(maskDirections)[0] \u000a        maskDirectionIndices = np.repeat(range(1,5), maskDirectionNumReps)\u000a        maskDirs = np.random.permutation(np.repeat(maskDirections,\u000a            maskDirectionNumReps,0))\u000a        # Setting the mask colours.\u000a        maskColIDs = np.array([thisMaskColRed, thisMaskColBlue, thisMaskColGreen,\u000a            thisMaskColYellow])\u000a        maskColAll = np.array([[1,-1,-1], [-1,-1,1], [-1,1,-1], [1,1,-1]])\u000a        maskColCurSet = maskColAll[maskColIDs==1]\u000a        maskColNumReps = nMaskElements/np.shape(maskColCurSet)[0]\u000a        maskColCurSetRepd = np.repeat(maskColCurSet, maskColNumReps, 0)\u000a        maskColours = np.random.permutation(maskColCurSetRepd)\u000a        mask.colors = maskColours\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        tMaskMove = 0\u000a        key_pressed = False\u000a        key_pause = False\u000a        windowLeft.lineColor = 'white'\u000a        windowRight.lineColor = 'white'\u000a        # Vertical offset of the target (dependent on the type of trial):\u000a        if thisTargLoc == 'above':\u000a            targOffsetY = windowOffsetY + targVertOffset\u000a        elif thisTargLoc == 'below':\u000a            targOffsetY = windowOffsetY - targVertOffset\u000a        else:\u000a            print 'Error! Please check your target location values.'\u000a        # update component parameters for each repeat\u000a        target.edges = thisTargVertices # updating the shape of the target\u000a        target.setFillColor(thisTargColour)\u000a        target.setLineColor(thisTargColour)\u000a        key_upDown = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_upDown.status = NOT_STARTED\u000a        key_space = event.BuilderKeyResponse()\u000a        key_space.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(windowLeft)\u000a        trialComponents.append(windowRight)\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(target)\u000a        trialComponents.append(mask)\u000a        trialComponents.append(fixationLeft)\u000a        trialComponents.append(fixationRight)\u000a        trialComponents.append(key_upDown)\u000a        trialComponents.append(key_space)\u000a        trialComponents.append(pauseTextLeft)\u000a        trialComponents.append(pauseTextRight)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1 # number of completed frames (0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *windowLeft* updates\u000a            if windowLeft.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                windowLeft.tStart = t  # underestimates by a little under one frame\u000a                windowLeft.frameNStart = frameN  # exact frame index\u000a                windowLeft.setAutoDraw(True)\u000a                fixationLeft.setAutoDraw(True)\u000a                blackBoxLeft.setAutoDraw(True)\u000a#            if windowLeft.status == STARTED and t >= stimOffset:\u000a#                windowLeft.setAutoDraw(False)\u000a#                fixationLeft.setAutoDraw(False)\u000a#                blackBoxLeft.setAutoDraw(False)\u000a            \u000a            # *windowRight* updates\u000a            if windowRight.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                windowRight.tStart = t  # underestimates by a little under one frame\u000a                windowRight.frameNStart = frameN  # exact frame index\u000a                windowRight.setAutoDraw(True)\u000a                fixationRight.setAutoDraw(True)\u000a                blackBoxRight.setAutoDraw(True)\u000a#            if windowRight.status == STARTED: #and t >= stimOffset:\u000a#                windowRight.setAutoDraw(False)\u000a#                fixationRight.setAutoDraw(False)\u000a#                blackBoxRight.setAutoDraw(False)\u000a\u000a            # if the target has already disappeared, yet the key is still not pressed\u005c\u000a            #   continue, the trial with the yellow boxes:\u000a            if ~key_pressed and t > stimOffset:\u000a                windowLeft.lineColor = 'yellow'\u000a                windowRight.lineColor = 'yellow'\u000a\u000a            # pause text (after the response is made):\u000a            if key_pressed and ~key_pause and t > stimOffset:\u000a                pauseTextLeft.setAutoDraw(True)\u000a                pauseTextRight.setAutoDraw(True)\u000a                windowLeft.lineColor = 'white'\u000a                windowRight.lineColor = 'white'\u000a\u000a            # *mask* updates\u000a            if mask.status == NOT_STARTED and t > preStimInterval:\u000a                mask.tStart = t\u000a                mask.frameNStart = frameN\u000a                # setting the initial positions for the mask elements\u000a                mask.xys = maskInitPos \u000a                mask.fieldPos = [maskOffsetX, windowOffsetY]\u000a                mask.setAutoDraw(True)\u000a                maskMoveClock.reset()\u000a            if mask.status == STARTED and t > preStimInterval and ~key_pressed:\u000a                if tMaskMove == 0:\u000a                    tMaskMove = frameDur # maskMoveClock.getTime()\u000a                    tMaskRec = maskMoveClock.getTime()\u000a                    maskMovePos = maskInitPos\u000a                else:\u000a                    tMaskMove = maskMoveClock.getTime() - tMaskRec\u000a                    tMaskRec = maskMoveClock.getTime()\u000a                maskMovePos = np.array(maskMovePos) + np.array(maskDirs) * \u005c\u000a                    thisMaskSpeed * tMaskMove\u000a                maskElemsOutside = np.where(abs(maskMovePos)>maxTravDist)\u000a                maskMovePos[maskElemsOutside] = -maxTravDist * \u005c\u000a                    maskMovePos[maskElemsOutside] / abs(maskMovePos[maskElemsOutside])\u000a                mask.xys = maskMovePos\u000a            if mask.status == STARTED and t >= stimOffset and key_pressed:\u000a                mask.setAutoDraw(False)\u000a\u000a            # *target* updates\u000a            if t >= preStimInterval and target.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                target.tStart = t  # underestimates by a little under one frame\u000a                target.frameNStart = frameN  # exact frame index\u000a                target.setAutoDraw(True)\u000a                edgeReached = False\u000a                moveClock.reset()\u000a            if target.status == STARTED:\u000a                curFrameN = frameN - target.frameNStart\u000a                if curFrameN < fadeInNofFrames:\u000a                    target.opacity = thisIntensity * (curFrameN / fadeInNofFrames)\u000a                else:\u000a                    target.opacity = thisIntensity\u000a                tMove = moveClock.getTime()\u000a                if edgeReached: # if the edge is reached, start from the other edge:\u000a                    travDist = tMove*thisTargSpeed-maxTravDist\u000a                else: # otherwise, start from the middle of the box:\u000a                    travDist = tMove*thisTargSpeed\u000a                # if the target has already moved beyond max allowed travel distance:\u000a                if travDist > maxTravDist:\u000a                    edgeReached = True\u000a                    moveClock.reset() # reset the movement clock (set it to zero)\u000a                    tMove = moveClock.getTime() # get the time\u000a                    # use that reset time for new travDist, but start from the edge:\u000a                    travDist = tMove*thisTargSpeed-maxTravDist\u000a                # target movement:\u000a                target.pos = [targOffsetX+thisTargDir*travDist, targOffsetY]\u000a            if target.status == STARTED and t >= stimOffset:\u000a                target.setAutoDraw(False)\u000a\u000a            # *key_space* updates\u000a            if ~key_pause and key_pressed and t >= stimOffset:\u000a#                spaceKey = event.getKeys(keyList=['space'])\u000a                if 'space' in event.getKeys(keyList=['space']):\u000a                    print 'spacebar pressed'\u000a                    key_pause = True\u000a            \u000a            # *key_upDown* updates\u000a            if t >= preStimInterval and key_upDown.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_upDown.tStart = t  # underestimates by a little under one frame\u000a                key_upDown.frameNStart = frameN  # exact frame index\u000a                key_upDown.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_upDown.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_upDown.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['up', 'down'])\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_upDown.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_upDown.rt = key_upDown.clock.getTime()\u000a                    key_pressed = True\u000a                    # was this 'correct'?\u000a                    if (key_upDown.keys == str(thisTargCorrAns)) or \u005c\u000a                            (key_upDown.keys == thisTargCorrAns):\u000a                        print 'correct response'\u000a                        key_upDown.corr = 1\u000a                    else:\u000a                        print 'incorrect response'\u000a                        key_upDown.corr = 0\u000a                    # update staircase:\u000a                    thisStair.addData(key_upDown.corr)\u000a                    thisStair.addOtherData('key_upDown.rt', key_upDown.rt)\u000a#                    ########\u000a#                    # Printing for debug:\u000a#                    print 'RT: %.3f' %(key_upDown.rt)\u000a#                    print thisStair.data\u000a\u000a            # if key is not pressed, do nothing\u000a            # if key is pressed, wait for the presentation time to pass to terminate\u005c\u000a            #   the trial:\u000a            if key_pressed and key_pause and t >= stimOffset:\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a            # *ISI* period\u000a            if ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(ISIduration)\u000a            #one frame should pass before updating params and completing\u000a            elif ISI.status == STARTED: \u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            # a component has requested a forced-end of Routine:\u000a            if not continueRoutine: \u000a                # if we abort early the non-slip timer needs reset:\u000a                routineTimer.reset() \u000a                break\u000a            # will revert to True if at least one component still running\u000a            continueRoutine = False  \u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and \u005c\u000a                        thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            # don't flip if this routine is over or we'll get a blank screen\u000a            if continueRoutine:  \u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a                    expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a                    expInfo['date'] + '_cond_' + thisStair.extraInfo['label'])\u000a                thisStair.saveAsPickle(stairFilename)\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a        thisExp.nextEntry()\u000a    \u000a# Writing the separate outputs for the staircases:\u000a#dateStr = time.strtime("%b_%d_%H%M", time.localtime())\u000a#condN = 0 # the conditions are simply defined by their numbers\u000afor thisStair in stairs:\u000a#    condN += 1\u000a    print 'reversals:'\u000a    print thisStair.reversalIntensities\u000a    print 'mean of final 6 reversals = %.3f' \u005c\u000a        %(np.average(thisStair.reversalIntensities[-6:]))\u000a    stairFilename = filename + os.sep + '%s_%s_%s_%s_%s' %(expName, \u005c\u000a        expInfo['participant'], expInfo['domEye'], expInfo['session'], \u005c\u000a        expInfo['date'] + '_cond_' + thisStair.extraInfo['label']) #str(condN))\u000a    thisStair.saveAsPickle(stairFilename)\u000a    thisStair.saveAsText(stairFilename)\u000a\u000awin.close()\u000acore.quit()\u000a
p7
sS'nDown'
p8
I2
sS'_exp'
p9
I249345552
sS'reversalIntensities'
p10
(lp11
cnumpy.core.multiarray
scalar
p12
(cnumpy
dtype
p13
(S'f8'
I0
I1
tRp14
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp15
ag12
(g14
S'\x00\x00\x00\x00\x00\x00\xe0?'
tRp16
ag12
(g14
S'\x98\x99\x99\x99\x99\x99\xb9?'
tRp17
ag12
(g14
S'333333\xd3?'
tRp18
ag12
(g14
S'\x99\x99\x99\x99\x99\x99\xc9?'
tRp19
ag12
(g14
S'333333\xd3?'
tRp20
ag12
(g14
S'433333\xc3?'
tRp21
ag12
(g14
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp22
ag12
(g14
S'\xecQ\xb8\x1e\x85\xeb\xc1?'
tRp23
ag12
(g14
S'\xc3\xf5(\\\x8f\xc2\xc5?'
tRp24
ag12
(g14
S'\xecQ\xb8\x1e\x85\xeb\xc1?'
tRp25
ag12
(g14
S'\xc3\xf5(\\\x8f\xc2\xc5?'
tRp26
asS'stepSizes'
p27
(lp28
F0.29999999999999999
aF0.29999999999999999
aF0.20000000000000001
aF0.20000000000000001
aF0.10000000000000001
aF0.10000000000000001
aF0.050000000000000003
aF0.050000000000000003
aF0.029999999999999999
aF0.029999999999999999
asS'nUp'
p29
I1
sS'startVal'
p30
g12
(g14
S'\x9a\x99\x99\x99\x99\x99\xe9?'
tRp31
sS'_nextIntensity'
p32
g12
(g14
S'\xecQ\xb8\x1e\x85\xeb\xc1?'
tRp33
sS'_warnUseOfNext'
p34
I01
sS'method'
p35
S'2AFC'
p36
sS'maxVal'
p37
I1
sS'stepSizeCurrent'
p38
F0.029999999999999999
sS'correctCounter'
p39
I0
sS'nReversals'
p40
I10
sS'minVal'
p41
I0
sS'otherData'
p42
(dp43
S'key_upDown.rt'
p44
(lp45
F1.1807730197906494
aF1.4980170726776123
aF2.538848876953125
aF1.4206619262695312
aF0.71280598640441895
aF1.5668258666992188
aF0.96372890472412109
aF2.1347980499267578
aF1.5995190143585205
aF0.88182806968688965
aF0.95110917091369629
aF2.7007460594177246
aF0.9372251033782959
aF1.3985490798950195
aF1.5313229560852051
aF0.99808692932128906
aF1.4316270351409912
aF0.79691791534423828
aF2.5079610347747803
aF2.4847099781036377
aF1.1475338935852051
aF1.3975191116333008
aF2.3845930099487305
aF1.0307149887084961
aF1.6987149715423584
aF1.6652131080627441
aF2.6130800247192383
aF2.5842611789703369
aF2.4501960277557373
aF1.6369531154632568
assS'finished'
p46
I01
sS'stepType'
p47
S'lin'
p48
sS'data'
p49
(lp50
I1
aI1
aI0
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI1
aI1
aI0
aI1
aI1
aI0
aI1
aI1
asS'reversalPoints'
p51
(lp52
I2
aI4
aI7
aI9
aI11
aI13
aI19
aI21
aI24
aI26
aI27
aI29
asS'originPath'
p53
S'/Users/egor/Dropbox/projects/supr-eff/supreff/supreff.py'
p54
sS'name'
p55
S''
sS'extraInfo'
p56
(dp57
S'maskColYellow'
p58
g12
(g13
(S'i8'
I0
I1
tRp59
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp60
sS'targCorrAns'
p61
S'up'
p62
sS'maskSize'
p63
g12
(g14
S'q=\n\xd7\xa3p\xdd?'
tRp64
sS'maskColGrey'
p65
g12
(g59
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp66
sS'maskVertices'
p67
g12
(g59
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp68
sS'maskColBlue'
p69
g12
(g59
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp70
sS'targSize'
p71
g12
(g14
S'q=\n\xd7\xa3p\xdd?'
tRp72
sS'targColour'
p73
S'red'
p74
sS'label'
p75
S'5-above_h'
p76
sS'combi_dirXpos'
p77
cnumpy.core.multiarray
_reconstruct
p78
(cnumpy
ndarray
p79
(I0
tS'b'
tRp80
(I1
(I30
I2
tg13
(S'i4'
I0
I1
tRp81
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00'
tbsS'targVertices'
p82
g12
(g59
S'\x10\x00\x00\x00\x00\x00\x00\x00'
tRp83
sS'maskColRed'
p84
g12
(g59
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp85
sS'maskSpeed'
p86
g12
(g59
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp87
sS'targSpeed'
p88
g12
(g59
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp89
sS'startVal'
p90
g31
sS'maskColGreen'
p91
g12
(g59
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp92
sS'targLoc'
p93
S'above'
p94
ssS'currentDirection'
p95
S'down'
p96
sS'_variableStep'
p97
I01
sS'intensities'
p98
(lp99
g31
ag12
(g14
S'\x00\x00\x00\x00\x00\x00\xe0?'
tRp100
ag15
ag16
ag16
ag12
(g14
S'333333\xd3?'
tRp101
ag101
ag17
ag18
ag18
ag19
ag19
ag20
ag20
ag12
(g14
S'\x00\x00\x00\x00\x00\x00\xd0?'
tRp102
ag102
ag12
(g14
S'\x9a\x99\x99\x99\x99\x99\xc9?'
tRp103
ag103
ag21
ag21
ag22
ag22
ag12
(g14
S'\xc3\xf5(\\\x8f\xc2\xc5?'
tRp104
ag104
ag23
ag24
ag24
ag25
ag26
ag26
asS'initialRule'
p105
I0
sS'nTrials'
p106
I30
sS'thisTrialN'
p107
I29
sS'autoLog'
p108
I01
sb.